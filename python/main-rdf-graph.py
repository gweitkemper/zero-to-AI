"""
Usage:
    python main-rdf-graph.py build_rdf_graph
    python main-rdf-graph.py query <query-name> <query-param>
    python main-rdf-graph.py query count_all_triples
    python main-rdf-graph.py query show_all_triples
    python main-rdf-graph.py query deps_for_library azure-cosmos
    python main-rdf-graph.py query deps_for_library jupyter
    python main-rdf-graph.py query centrality_sparql_query

"""

import sys
import traceback
from typing import Any

from docopt import docopt
from dotenv import load_dotenv

from rdflib import Graph, Namespace, URIRef, Literal
from rdflib.namespace import RDF, RDFS, OWL, XSD

from src.io.fs import FS

# Chris Joakim, 3Cloud/Cognizant, 2026


def print_options(msg):
    print(msg)
    arguments = docopt(__doc__, version="1.0.0")
    print(arguments)


def namespace():
    return "http://example.org/libgraph"


def build_rdf_graph():
    g = create_ontology()
    wrangle_and_add_triples(g)
    print(f"graph length: {len(g)}")

    # the graph can be serialized to multiple equivalent formats
    for format in ["xml", "turtle", "nt", "json-ld"]:
        outfile = f"rdf/graph.{format}"
        g.serialize(destination=outfile, format=format, encoding="utf-8")
        print(f"Serialized to {outfile}")
    return g


def create_ontology():
    """
    This method was generated by Cursor from the following prompt:

    Create a RDFLib ontology OWL file for the RDF Graph Model
    shown below and update method create_ontology() method in
    file main-rdf-graph.py with the Python code to create the ontology.

    RDF Graph Model
    - Types
        - Library
          - attribute: name (string)
    - Relationships (Type -> Relationship -> Type)
        - Library -> uses_lib -> Library
        - Library -> used_by_lib -> Library
    """
    # Define namespaces
    CODE = Namespace("http://example.org/libgraph#")
    BASE = Namespace("http://example.org/libgraph/")

    # Create a new RDF graph, an instance of class rdflib.graph.Graph
    g = Graph()

    # Bind namespaces
    g.bind("", CODE)  # Set CODE as the default namespace
    g.bind("libgraph", CODE)
    g.bind("rdf", RDF)
    g.bind("rdfs", RDFS)
    g.bind("owl", OWL)
    g.bind("xsd", XSD)

    # Define the ontology
    ontology = URIRef(namespace())
    g.add((ontology, RDF.type, OWL.Ontology))
    g.add((ontology, RDFS.label, Literal("Library Graph Ontology")))
    g.add(
        (
            ontology,
            RDFS.comment,
            Literal(
                "Ontology for the RDF Graph Model representing Python Libraries in this project"
            ),
        )
    )

    # Cursor added generated code here
    # Library class
    Library = CODE.Library
    g.add((Library, RDF.type, OWL.Class))
    g.add((Library, RDFS.label, Literal("Library")))
    g.add((Library, RDFS.comment, Literal("A Python library in the dependency graph")))

    # name datatype property (Library -> xsd:string)
    name_prop = CODE.name
    g.add((name_prop, RDF.type, OWL.DatatypeProperty))
    g.add((name_prop, RDFS.domain, Library))
    g.add((name_prop, RDFS.range, XSD.string))
    g.add((name_prop, RDFS.label, Literal("name")))

    # uses_lib object property (Library -> Library)
    uses_lib = CODE.uses_lib
    g.add((uses_lib, RDF.type, OWL.ObjectProperty))
    g.add((uses_lib, RDFS.domain, Library))
    g.add((uses_lib, RDFS.range, Library))
    g.add((uses_lib, RDFS.label, Literal("uses_lib")))

    # It was later decided to not use the used_by_lib property, as it was not necessary.
    # used_by_lib object property (Library -> Library), inverse of uses_lib
    # used_by_lib = CODE.used_by_lib
    # g.add((used_by_lib, RDF.type, OWL.ObjectProperty))
    # g.add((used_by_lib, RDFS.domain, Library))
    # g.add((used_by_lib, RDFS.range, Library))
    # g.add((used_by_lib, RDFS.label, Literal("used_by_lib")))
    # g.add((uses_lib, OWL.inverseOf, used_by_lib))

    owl_file = "rdf/graph.owl"
    g.serialize(destination=owl_file, format="xml")
    print(f"Generated {owl_file} successfully")
    return g


def wrangle_and_add_triples(g: Graph):
    # The input 'data/uv/uv-cyclonedx.json' file was created in the venv.sh script
    # using this command: uv export --format cyclonedx1.5 > data/uv/uv-cyclonedx.json
    # Thus, uv itself provides much of the raw data necessary for this graph.

    cyclone_dict = FS.read_json("data/uv/uv-cyclonedx.json")
    print(f"cyclone_dict keys: {sorted(cyclone_dict.keys())}")
    libname_lookup_dict = dict[str, str]()
    libs_and_dependencies_dict = dict()

    components_list = cyclone_dict["components"]
    dependencies_list = cyclone_dict["dependencies"]
    print(f"components length {len(components_list)}")
    print(f"dependencies length {len(dependencies_list)}")

    for comp in components_list:
        if comp["type"] == "library":
            name = comp["name"]
            bom_ref = comp["bom-ref"]
            libname_lookup_dict[name] = bom_ref
            libname_lookup_dict[bom_ref] = name
    # Capture intermediate results file for debugging and analysis
    FS.write_json(libname_lookup_dict, "tmp/libname_lookup_dict.json", sort_keys=True)

    # Iterate over the dependencies_list and build the libs_and_dependencies_dict
    for dep in dependencies_list:
        ref = dep["ref"]
        if ref.startswith("zero-to-ai"):
            pass
        else:
            lib_dict = dict()
            name = libname_lookup_dict[ref]
            lib_dict["ref"] = ref
            lib_dict["name"] = name
            lib_dict["dependencies"] = list()
            for name_and_version in dep["dependsOn"]:
                lib_name = libname_lookup_dict[name_and_version]
                lib_dict["dependencies"].append(lib_name)
            libs_and_dependencies_dict[name] = lib_dict
    # Capture intermediate results file for debugging and analysis
    FS.write_json(libs_and_dependencies_dict, "tmp/libs_and_dependencies_dict.json", sort_keys=True)

    # This loop adds the each lib_name as a RDF.type of type Library to the graph.
    # Triples are added to the graph (subject, predicate, object)
    for lib_name in sorted(collect_all_lib_names(libs_and_dependencies_dict)):
        subject = URIRef(f"{namespace()}/{lib_name}")
        predicate = RDF.type
        object_type = URIRef("http://example.org/libgraph#Library")
        g.add((subject, predicate, object_type))

    # This loop adds the "uses_lib" relationships to the graph
    for lib_name in sorted(libs_and_dependencies_dict.keys()):
        lib_deps = libs_and_dependencies_dict[lib_name]["dependencies"]
        for lib_dep_name in lib_deps:
            subject = URIRef(f"{namespace()}/{lib_name}")
            predicate = URIRef("http://example.org/libgraph#uses_lib")
            object = URIRef(f"{namespace()}/{lib_dep_name}")
            g.add((subject, predicate, object))


def collect_all_lib_names(libs_and_dependencies_dict):
    # Collect all of the library names, including leaf nodes with no dependencies
    lib_names = dict()
    for lib_name in libs_and_dependencies_dict.keys():
        lib_names[lib_name] = 1
        lib_deps = libs_and_dependencies_dict[lib_name]["dependencies"]
        for lib_dep_name in lib_deps:
            lib_names[lib_dep_name] = 1
    return sorted(lib_names.keys())


def query():
    """Load the graph, execute the specified SPARQL query, print the results."""
    try:
        infile = "rdf/graph.xml"
        g = Graph()
        g.bind("libgraph", Namespace("http://example.org/libgraph#"))
        g.parse(infile, format="xml")
        print(f"Loaded {infile} (size {len(g)})")

        query_name = sys.argv[2]
        if query_name == "count_all_triples":
            q = count_triples_sparql_query()
        elif query_name == "show_all_triples":
            q = all_triples_sparql_query()
        elif query_name == "deps_for_library":
            lib_name = sys.argv[3]
            q = dependences_for_library_sparql_query(lib_name)
        elif query_name == "centrality_sparql_query":
            q = centrality_sparql_query()
        else:
            print_options(f"Invalid query name: " + query_name)
            return

        for row in g.query(q):
            print(row)
            # name = str(row.dep).split("/")[-1]
            # print(f"  depth {row.minDepth}: {name}")
    except Exception as e:
        print("traceback: " + traceback.format_exc())
        print_options("exception: " + str(e))


def all_triples_sparql_query():
    # s = subject, p = predicate, o = object
    return "SELECT ?s ?p ?o WHERE { ?s ?p ?o . } limit 10000"


def count_triples_sparql_query():
    # s = subject, p = predicate, o = object
    return "SELECT (COUNT(*) AS ?count) WHERE { ?s ?p ?o . }"


"""
Cursor prompt to generate the code in the following function:

Given the Ontology file 'rdf/graph.owl', and the RDF Graph data in file 'rdf/graph.xml',
write a SPARQL query to query the graph for a given library such as 'azure-cosmos'
for its dependencies, and all of their recursive dependencies.
Return a list of the dependencies in order of dependency depth.
Add the query code to the 'dependences_for_library_sparql_query(lib_name)' method below.
"""


def dependences_for_library_sparql_query(lib_name):
    """
    SPARQL query returning all dependencies of lib_name (direct + recursive),
    each with its minimum depth, ordered by depth then by dependency URI.
    """
    lib_uri = f"<{namespace()}/{lib_name}>"
    max_depth = 20

    union_parts = []
    for d in range(1, max_depth + 1):
        bind_depth = f"BIND({d} AS ?depth)"
        if d == 1:
            triples = f"{lib_uri} libgraph:uses_lib ?dep ."
        else:
            mids = " . ".join(f"?m{i} libgraph:uses_lib ?m{i + 1}" for i in range(d - 1))
            triples = (
                f"{lib_uri} libgraph:uses_lib ?m0 . {mids} . ?m{d - 1} libgraph:uses_lib ?dep ."
            )
        filter_out_root = f" FILTER (?dep != {lib_uri})"
        union_parts.append("{" + bind_depth + " " + triples + filter_out_root + "}")

    query = f"""
    PREFIX libgraph: <http://example.org/libgraph#>
    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

    SELECT ?dep (MIN(?depth) AS ?minDepth)
    WHERE {{
      {" UNION ".join(union_parts)}
    }}
    GROUP BY ?dep
    ORDER BY ?minDepth ?dep
    """
    return query


"""
Cursor prompt to generate the code in the following function:

Given the Ontology file 'rdf/graph.owl', and the RDF Graph data in file 'rdf/graph.xml',
write a SPARQL query to query the graph for the most commonly used libraries
and rank them by the number of uses_lib relationships.
Return a list of the top 10 libraries and their use counts.
Add the query code to the 'centrality_sparql_query(lib_name)' method below.
"""


def centrality_sparql_query():
    """
    SPARQL query returning the top 10 most commonly used libraries,
    ranked by number of uses_lib relationships (in-degree).
    lib_name is unused; kept for API consistency.
    """
    query = """
    PREFIX libgraph: <http://example.org/libgraph#>
    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

    SELECT ?lib (COUNT(*) AS ?useCount)
    WHERE {
      ?user libgraph:uses_lib ?lib .
    }
    GROUP BY ?lib
    ORDER BY DESC(?useCount)
    LIMIT 10
    """
    return query


def paas_service_sparql_query(paas_service_name):
    paas_service_uri = f"<{namespace()}/{paas_service_name}>"

    query = f"""
    PREFIX libgraph: <http://example.org/libgraph#>
    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
    
    SELECT DISTINCT ?pythonClass
    WHERE {{
        # Find the PaasService instance
        {paas_service_uri} rdf:type libgraph:PaasService .
        
        {{
            # Direct use: PythonClass directly uses the PaasService
            ?pythonClass rdf:type libgraph:PythonClass .
            ?pythonClass libgraph:uses_paas_service {paas_service_uri} .
        }}
        UNION
        {{
            # Indirect use: PythonClass uses other PythonClasses (transitively) 
            # that eventually use the PaasService
            ?pythonClass rdf:type libgraph:PythonClass .
            ?pythonClass libgraph:uses_python_class+ ?intermediateClass .
            ?intermediateClass rdf:type libgraph:PythonClass .
            ?intermediateClass libgraph:uses_paas_service {paas_service_uri} .
        }}
    }}
    """
    return query


if __name__ == "__main__":
    try:
        load_dotenv(override=True)
        function_name = sys.argv[1]
        if function_name == "build_rdf_graph":
            build_rdf_graph()
        elif function_name == "query":
            query()
        else:
            print_options(f"Invalid function name: " + function_name)
    except Exception as e:
        print("traceback: " + traceback.format_exc())
        print_options("exception: " + str(e))
